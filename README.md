# linux-for-hacker-and-pentester


CAP 1 INTRODUZIONE
CAP 2 TEXT MANIPULATION
CAP 3 FONDAMENTI DI RETI
CAP 4 USO DI APT PER AGGIUNGRE E RIMUOVERE SOFTWARE 

# Introduzione :



**Binaries** : This term refers to files that can be executed, similar to executables in Windows.
Binaries generally reside in the /usr/bin or usr/sbin directory and include utilities such as ps, cat, ls, 
and cd (we’ll touch on all of four of these in this chapter) 
as well as applications such as the wireless hacking tool aircrack-ng and the intrusion detection system (IDS) Snort.

**Case sensitivity** : Unlike Windows, Linux is case sensitive. This means that Desktop is different from desktop, which is different from DeskTop. Each of these would 
represent a different file or directory name. Many people coming from a Windows environment can find this frustrating. If you get the error message “file or directory not found” and you are sure the file or directory exists, you probably need to check your case.

**Directory** : This is the same as a folder in Windows. A directory provides a way of organizing files, usually in a hierarchical mann”

**root**  :Like nearly every operating system, Linux has an administrator or superuser account, designed for use by a trusted person who can do nearly anything on the system. This would include such things as reconfiguring the system, adding users, and changing passwords. In Linux, that account is called root. As a hacker or pentester, you will often use the root account to give yourself control over the system. In fact, many hacker tools require that you use the root account.


**Script** : This is a series of commands run in an interpretive environment that converts each line to source code. Many hacking tools are simply scripts. Scripts can be run with the bash interpreter or any of the other scripting language interpreters, such as Python, Perl, or Ruby. Python is currently the most popular interpreter among hackers.

**Shell** : This is an environment and interpreter for running commands in Linux. The most widely used shell is bash, which stands for Bourne-again shell, but other popular shells include the C shell and Z shell. I will be using the bash shell exclusively in this book.


## file system


Il file system in Linux è l'organizzazione gerarchica dei file su un sistema operativo basato su kernel Linux. La struttura del file system segue il modello ad albero, con la directory radice indicata da "/". 
Linux non ha un'unità fisica (come l'unità C:) alla base del filesystem, ma usa invece un filesystem logico.

<img width="666" alt="Screenshot 2024-02-15 alle 10 55 41" src="https://github.com/MrMagicalSoftware/linux-for-hacker-and-pentester/assets/98833112/5070c9ec-06e4-4b27-a4be-77b150bcfc27">






1. **/ (root):** La directory radice del sistema di file. Tutti i file e le directory si trovano sotto questa directory principale.

2. **/bin (binary):** Contiene i file binari essenziali necessari per il funzionamento del sistema e il ripristino in caso di problemi.

3. **/boot:** Contiene i file necessari per il caricamento del kernel Linux durante l'avvio del sistema.

4. **/dev (devices):** Contiene file speciali che rappresentano dispositivi hardware. Ad esempio, i file nella directory /dev possono rappresentare dischi, dispositivi di input, ecc.

5. **/etc (et cetera):** Contiene i file di configurazione del sistema. Qui si trovano molte configurazioni globali del sistema e delle applicazioni.

6. **/home:** Questa è la directory principale per gli utenti del sistema. Ogni utente ha la propria sottodirectory qui, ad esempio, /home/nomeutente.

7. **/lib (library):** Contiene le librerie condivise essenziali necessarie per il funzionamento del sistema e dei programmi di sistema.

8. **/media:** Utilizzato per montare temporaneamente dispositivi rimovibili come chiavette USB o unità CD/DVD.

9. **/mnt (mount):** Utilizzato per montare temporaneamente file system aggiuntivi o dispositivi di archiviazione.

10. **/opt (optional):** Spazio destinato per l'installazione di software aggiuntivo che non fa parte del sistema principale.

11. **/proc:** Un file system virtuale che fornisce informazioni sul kernel, i processi e il sistema in tempo reale.

12. **/root:** La directory home dell'utente root, l'amministratore del sistema.

13. **/sbin (system binaries):** Contiene i file binari di sistema essenziali utilizzati solo dall'amministratore del sistema.

14. **/srv (service):** Contiene dati specifici del servizio fornito da questo sistema.

15. **/tmp (temporary):** Utilizzato per archiviare file temporanei. Il contenuto di questa directory viene cancellato durante il riavvio del sistema.

16. **/usr (user):** Contiene la maggior parte dei programmi e dei file a cui gli utenti accedono regolarmente. Spesso separato in /usr/bin, /usr/lib, ecc.

17. **/var (variable):** Contiene dati variabili, come log di sistema, file di stampa e altri dati che possono variare nel tempo.



## COMANDI ESSENZIALI 


Il comando `whoami` in un sistema Unix/Linux restituisce il nome dell'utente che attualmente ha effettuato l'accesso al sistema. In altre parole, mostra il nome dell'utente associato all'identità corrente dell'esecuzione del comando.

Per utilizzare il comando `whoami`, apri il terminale e digita semplicemente:

```bash
whoami
```

Dopo aver premuto Invio, il terminale mostrerà il nome dell'utente associato alla sessione corrente.

Ad esempio, se sei loggato come utente "john", il comando `whoami` restituirà:

```
john
```

Questo comando è utile quando si lavora con script o comandi che richiedono informazioni sull'utente corrente. Può essere usato anche per verificare rapidamente sotto quale identità si sta eseguendo il terminale in un dato momento.



**COMANDO pwd**

Il comando `pwd` (Print Working Directory) in un sistema Unix/Linux restituisce il percorso completo (path) della directory corrente in cui ti trovi nel terminale. Quando lo esegui, il terminale mostra il percorso completo dalla radice del file system fino alla directory corrente.

Per utilizzare il comando `pwd`, basta digitare il comando nel terminale e premere Invio:

```bash
pwd
```

Il risultato sarà il percorso completo della directory corrente. Ad esempio:

```
/home/tuo_utente
```

Questo è particolarmente utile quando si naviga tra le directory o si lavora con file e cartelle in modo da sapere sempre in quale posizione del sistema di file ci si trova.


___________________________________




**COMANDO cd**


Il comando `cd` in Linux è utilizzato per cambiare la directory corrente del terminale.

1. **Cambiare alla tua home directory:**
   ```bash
   cd
   ```
   Questo ti porterà alla tua home directory personale.

2. **Cambiare a una directory specifica:**
   ```bash
   cd /percorso/della/nuova/directory
   ```
   Questo ti porterà alla directory specificata nel percorso.

3. **Ritornare alla directory superiore (una directory "indietro"):**
   ```bash
   cd ..
   ```
   Questo ti porterà alla directory genitore (superiore) rispetto a quella corrente.

4. **Ritornare direttamente alla directory home:**
   ```bash
   cd ~
   ```
   Questo ti porterà direttamente alla tua home directory, indipendentemente da dove ti trovi nel file system.

5. **Tornare alla directory precedente:**
   ```bash
   cd -
   ```
   Questo ti riporterà alla directory dalla quale sei appena entrato.

6. **Combinare più directory:**
   Puoi combinare più comandi `cd` usando la barra (/) come separatore:
   ```bash
   cd /percorso1/percorso2/percorso3
   ```
   Questo ti porterà alla directory finale specificata.


NOTA :

cd .. to move up one level <br>
cd .. ..  to move up two levels<br>
cd .. .. .. and so on <br>




**Listing the Contents of a Directory with ls**





Il comando `ls` in Linux è utilizzato per elencare i file e le directory presenti nella directory corrente. 

<img width="655" alt="Screenshot 2024-02-15 alle 11 11 51" src="https://github.com/MrMagicalSoftware/linux-for-hacker-and-pentester/assets/98833112/f8545a80-6e09-42bc-a509-3a4fc1c11dc7">

<img width="671" alt="Screenshot 2024-02-15 alle 11 11 57" src="https://github.com/MrMagicalSoftware/linux-for-hacker-and-pentester/assets/98833112/5b5bfe8a-3a89-41ed-a32a-c6cf649ed208">




1. **Elencare i file e le directory nella directory corrente:**
   ```bash
   ls
   ```
   Questo mostra un elenco di file e directory nella posizione corrente del terminale.

2. **Elencare i file e le directory in una directory specifica:**
   ```bash
   ls /percorso/della/nuova/directory
   ```
   Questo mostra un elenco di file e directory nella directory specificata nel percorso.

3. **Elencare i file con dettagli (mostra le informazioni complete):**
   ```bash
   ls -l
   ```
   Questo mostra un elenco dettagliato, includendo informazioni come i permessi, il numero di collegamenti, il proprietario, il gruppo, la dimensione, la data e l'orario di ultima modifica.

4. **Elencare tutti i file, inclusi quelli nascosti (inizia con punto):**
   ```bash
   ls -a
   ```
   Questo mostra tutti i file, inclusi quelli i cui nomi iniziano con un punto (che sono considerati nascosti in Linux).

5. **Elencare i file con dettagli, inclusi quelli nascosti:**
   ```bash
   ls -la
   ```
   Questo mostra un elenco dettagliato di tutti i file, inclusi quelli nascosti.

6. **Ordinare i file per data di modifica:**
   ```bash
   ls -lt
   ```
   Questo ordina i file in base alla data di ultima modifica, mostrando prima i file più recenti.

7. **Visualizzare i file con dettagli e ordinati per data (inclusi nascosti):**
   ```bash
   ls -lta
   ```
   Questo mostra un elenco dettagliato di tutti i file, inclusi quelli nascosti, ordinati per data di ultima modifica.

8. **Elencare solo i file (senza directory):**
   ```bash
   ls -p | grep -v /
   ```
   Questo mostra solo i file nella directory corrente, escludendo le directory.


________________________________

**utilizzo dell' help**


Quando si usano i comandi per capire come funzionano si può utilizzare 
-h , oppure --help , ogni comando ha la sua notazione.


```
aircrack-ng --help
nmap -h
```


si può anche utilizzare il comando man


<img width="655" alt="Screenshot 2024-02-16 alle 10 30 45" src="https://github.com/MrMagicalSoftware/linux-for-hacker-and-pentester/assets/98833112/1ea4cb1c-6b8a-4976-9ba9-31d54b0147f2">

To exit, simply enter q (for quit), and you’ll return to the command prompt.


____________________________________________________________________________


**FINDING STUFF**


Il comando `locate` in Linux è utilizzato per trovare la posizione di file e directory nel sistema di file basandosi su un database pre-generato di nomi di file. Questo comando è utile per cercare rapidamente file o directory senza dover esplorare manualmente l'intero sistema di file. Tuttavia, è importante notare che `locate` utilizza un database pre-generato, quindi potrebbe non riflettere i cambiamenti più recenti nel file system. Per mantenere il database aggiornato, è possibile eseguire il comando `updatedb`.

Ecco alcuni esempi di come utilizzare il comando `locate`:

1. **Cercare un file specifico:**
   ```bash
   locate nome_del_file
   ```
   Questo cercherà e visualizzerà tutte le occorrenze del file con il nome specificato nel sistema di file.

2. **Cercare una directory specifica:**
   ```bash
   locate /percorso/della/nuova/directory
   ```
   Questo cercherà e visualizzerà tutte le occorrenze della directory specificata nel sistema di file.

3. **Cercare file con un determinato modello di nome:**
   ```bash
   locate *.txt
   ```
   Questo cercherà e visualizzerà tutti i file con estensione ".txt" nel sistema di file.

4. **Cercare file case-insensitive:**
   ```bash
   locate -i Nome_Del_File
   ```
   Questo eseguirà una ricerca case-insensitive del file specificato.

5. **Aggiornare il database prima di eseguire una ricerca:**
   ```bash
   sudo updatedb
   locate nome_del_file
   ```
   Questo aggiorna il database prima di eseguire la ricerca per assicurarsi che i risultati siano aggiornati.

6. **Visualizzare un numero specifico di risultati:**
   ```bash
   locate -n 5 nome_del_file
   ```
   Questo visualizzerà solo i primi 5 risultati della ricerca.


<img width="653" alt="Screenshot 2024-02-16 alle 10 36 05" src="https://github.com/MrMagicalSoftware/linux-for-hacker-and-pentester/assets/98833112/bb357323-2043-45fb-af10-e38f07168324">


**Finding Binaries with whereis**




Il comando `whereis` in Linux è utilizzato per trovare la posizione dei binari, delle pagine di manuale e delle sorgenti di un comando o programma specifico. Questo comando cerca in posizioni standard del sistema dove i programmi e i loro componenti sono comunemente archiviati.


<img width="658" alt="Screenshot 2024-02-16 alle 10 40 16" src="https://github.com/MrMagicalSoftware/linux-for-hacker-and-pentester/assets/98833112/c8104043-c769-4cdd-b845-3297dc3a9390">





1. **Cercare il binario di un comando:**
   ```bash
   whereis nome_del_comando
   ```
   Questo restituirà la posizione del binario eseguibile del comando specificato.

2. **Cercare le pagine di manuale di un comando:**
   ```bash
   whereis -m nome_del_comando
   ```
   Questo restituirà la posizione delle pagine di manuale associate al comando.

3. **Cercare sia il binario che le pagine di manuale di un comando:**
   ```bash
   whereis -b -m nome_del_comando
   ```
   Questo restituirà sia la posizione del binario che delle pagine di manuale del comando.

4. **Cercare le sorgenti di un comando (se disponibili):**
   ```bash
   whereis -s nome_del_comando
   ```
   Questo restituirà la posizione delle sorgenti del comando, se sono disponibili.


**Finding Binaries in the PATH Variable with which**

Il comando `which` in Linux è utilizzato per trovare la posizione del file eseguibile associato a un comando specifico. Questo comando cerca il percorso del comando nell'ambiente di sistema e restituisce il percorso completo del file eseguibile.
Il comando `which` è utile per determinare quale versione di un comando verrà eseguita quando viene chiamato da un terminale. Può essere particolarmente utile in ambienti in cui esistono diverse versioni di un programma e si desidera assicurarsi di utilizzare la versione corretta.

1. **Cercare la posizione di un comando:**
   ```bash
   which nome_del_comando
   ```
   Questo restituirà il percorso completo del file eseguibile associato al comando specificato.

Ad esempio:
```bash
$ which ls
/bin/ls
```

Il risultato indica che il comando `ls` è situato nel percorso `/bin/ls`.




__________________________________________________________________________


**COMANDO FIND**


Il comando `find` in Linux è utilizzato per cercare file e directory nel sistema di file in base a vari criteri. Questo comando è molto potente e flessibile, consentendo di specificare diversi parametri di ricerca per trovare esattamente ciò di cui hai bisogno.


1. **Cercare un file per nome:**
   ```bash
   find /percorso -name "nome_file"
   ```
   Questo cercherà un file specifico nel percorso specificato.

2. **Cercare tutti i file con una determinata estensione:**
   ```bash
   find /percorso -name "*.txt"
   ```
   Questo cercherà tutti i file con estensione ".txt" nel percorso specificato.

3. **Cercare tutti i file modificati nelle ultime 24 ore:**
   ```bash
   find /percorso -mtime -1
   ```
   Questo cercherà i file che sono stati modificati nelle ultime 24 ore nel percorso specificato.

4. **Cercare file in base alle dimensioni:**
   ```bash
   find /percorso -size +1M
   ```
   Questo cercherà i file nel percorso specificato che sono più grandi di 1 megabyte.

5. **Cercare file e eseguire un'azione su di essi:**
   ```bash
   find /percorso -name "*.log" -exec rm {} \;
   ```
   Questo cercherà tutti i file con estensione ".log" nel percorso specificato e li eliminerà.

6. **Cercare file ignorando il case:**
   ```bash
   find /percorso -iname "nome_file"
   ```
   Questo cercherà un file specifico nel percorso specificato ignorando il case.

7. **Cercare e visualizzare solo i file (escludendo le directory):**
   ```bash
   find /percorso -type f
   ```
   Questo cercherà e visualizzerà solo i file nel percorso specificato, escludendo le directory.

8. **Cercare e visualizzare solo le directory (escludendo i file):**
   ```bash
   find /percorso -type d
   ```
   Questo cercherà e visualizzerà solo le directory nel percorso specificato, escludendo i file.


Esempio :


Let’s look in the /etc directory for all files that begin with apache2 and have any extension
```
find /etc -type f --name apache2.*/etc/apache2/apache2.conf”
```


_____________________________

**Filtering with grep**

Il comando `ps aux` in Linux è utilizzato per visualizzare un elenco dettagliato di tutti i processi in esecuzione sul sistema, mostrando informazioni come l'utente proprietario, l'ID del processo (PID), l'utilizzo della CPU, l'utilizzo della memoria e altri dettagli. Questo comando è particolarmente utile per monitorare l'attività del sistema e identificare i processi in esecuzione.

Opzioni utilizzate con `ps aux`:

- **`a`:** Mostra i processi di tutti gli utenti. Senza questa opzione, `ps` mostra solo i processi dell'utente corrente.
  
- **`u`:** Mostra una visualizzazione dettagliata, inclusi l'utente proprietario (USER), l'ID del processo (PID), l'ID del processo genitore (PPID), l'uso della CPU (%CPU), l'uso della memoria (%MEM), il tempo di CPU consumato (TIME), il comando del processo (COMMAND), e altre informazioni.

- **`x`:** Mostra anche i processi che non sono associati a un terminale. Questo è utile per visualizzare i processi di sistema che potrebbero non essere legati a una sessione utente specifica.

Esempio di  `ps aux`, 

```
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1  12345  6789 ?        Ss   Feb14   0:02 /sbin/init
user1     123  1.0  2.3  98765 54321 pts/0    Sl   Feb14   1:23 /usr/bin/example
...
```

Nella tabella sopra, "USER" rappresenta l'utente proprietario del processo, "PID" è l'ID del processo, "%CPU" è l'utilizzo attuale della CPU, "%MEM" è l'utilizzo della memoria, e così via.


Come faccio a cercare un un processo per vedere se è attivo nella macchina.

```
> ps aux | grep apache
```

____________________________________________



## LAVORARE CON FILE E CARTELLE


CAT ---> SIGNIFICA CONCATENATE 

The cat command is generally used for displaying the contents of a file, but it can also be used to create small files. 
For creating bigger files, it’s better to enter the code in a text editor such as vim, emacs, leafpad, gedit, or kate and then save it as a file.



1. **Visualizzare il contenuto di un file:**
   ```bash
   cat nome_del_file
   ```
   Questo mostra il contenuto completo di un file sul terminale.

2. **Concatenare più file e visualizzarli:**
   ```bash
   cat file1 file2
   ```
   Questo concatenerebbe il contenuto di `file1` e `file2` e mostrerebbe l'output combinato.

3. **Creare un nuovo file:**
   ```bash
   cat > nuovo_file
   ```
   Puoi utilizzare `cat` per creare un nuovo file. Dopo aver eseguito questo comando, puoi inserire il testo e premere `Ctrl + D` per salvare il file.

4. **Concatenare e creare un nuovo file:**
   ```bash
   cat file1 file2 > nuovo_file
   ```
   Questo concatenerebbe il contenuto di `file1` e `file2` e salverebbe l'output nel nuovo file.

5. **Visualizzare numeri di riga con il contenuto del file:**
   ```bash
   cat -n nome_del_file
   ```
   Questo mostra il contenuto del file con numeri di riga.

6. **Visualizzare il contenuto di più file con numeri di riga:**
   ```bash
   cat -n file1 file2
   ```
   Questo mostra il contenuto combinato di `file1` e `file2` con numeri di riga.

7. **Concatenare e visualizzare file con l'inserimento di una linea vuota tra di essi:**
   ```bash
   cat file1 - file2
   ```
   Questo inserisce una linea vuota tra i contenuti di `file1` e `file2`.



Il comando `cat >>` in Linux viene utilizzato per concatenare o aggiungere il contenuto di uno o più file in un nuovo file o in un file esistente. La doppia freccia `>>` viene utilizzata per l'operazione di append, il che significa che il contenuto viene aggiunto alla fine del file target senza sovrascrivere il suo contenuto esistente.


Esempio comando `cat >>`:

1. **Aggiungere il contenuto da una sorgente al file `hackingskills`:**
   ```bash
   cat sorgente.txt >> hackingskills
   ```
   Questo prenderà il contenuto di `sorgente.txt` e lo aggiungerà alla fine di `hackingskills`.

2. **Aggiungere il testo direttamente da terminale:**
   ```bash
   cat >> hackingskills
   ```
   Dopo aver eseguito questo comando, puoi inserire del testo direttamente nel terminale. Premi `Ctrl + D` quando hai finito di inserire il testo per salvare il file.

se `hackingskills` non esiste, questo comando creerà un nuovo file con quel nome. Se il file esiste già, il contenuto verrà aggiunto alla fine del file senza sovrascrivere il suo contenuto esistente.




**COMANDO touch**


comando `touch` in Linux è utilizzato per creare file vuoti o per aggiornare il timestamp di accesso e modifica di file esistenti. 
Il comando `touch` è utile per la gestione dei timestamp dei file e per creare rapidamente file vuoti quando necessario.




1. **Creare un nuovo file vuoto:**
   ```bash
   touch nuovo_file.txt
   ```
   Questo comando crea un nuovo file vuoto chiamato `nuovo_file.txt` nella directory corrente.

2. **Aggiornare il timestamp di accesso e modifica di un file esistente:**
   ```bash
   touch file_esistente.txt
   ```
   Se `file_esistente.txt` già esiste, `touch` aggiornerà il timestamp di accesso e modifica del file all'orario corrente senza modificare il contenuto del file.

3. **Creare più file vuoti contemporaneamente:**
   ```bash
   touch file1.txt file2.txt file3.txt
   ```
   Questo crea contemporaneamente i file vuoti `file1.txt`, `file2.txt` e `file3.txt`.

4. **Creare un file con un timestamp specifico:**
   ```bash
   touch -t 202202151200 file_con_timestamp.txt
   ```
   Questo crea un file chiamato `file_con_timestamp.txt` con un timestamp specifico (nel formato AAAAMMGGHHMM) di "15 febbraio 2022 alle 12:00".

5. **Creare file con estensione specifica:**
   ```bash
   touch {file1,file2,file3}.txt
   ```
   Questo crea contemporaneamente i file vuoti `file1.txt`, `file2.txt` e `file3.txt` utilizzando la sintassi delle parentesi graffe per specificare una lista di nomi di file.


___________________


**CREAZIONE DI DIRECTORY**

```bash
   mkdir nuovaDirectory
```

**COPIARE UN FILE**
```bash
   cp oldfile /root/cartella/nuovofile
```


**RINOMINARE UN FILE**


Unfortunately, Linux doesn’t have a command intended solely for renaming a file, as Windows and some other operating systems do, but it does have the mv (move) command.
The mv command can be used to move a file or directory to a new location or simply to give an existing file a new name. To rename newfile to newfile2, you would enter the following:


```bash
mv newfile newfile2kali >lsoldfile newfile2”
```
Now when you list (ls) that directory, you see newfile2 but not newfile, because it has been renamed. You can do the same with directories.



**CANCELLARE UN FILE**


ATTENZIONE CON L'USO DI rm i file non vanno nel cestino!!

```bash

rm nomedelfileDaCancellare
```


**RIMUOVERE UNA DIRECTORY**


Il comando per rimuovere una directory in Linux è `rmdir` o `rm`. Tuttavia, ci sono alcune differenze tra i due comandi.

1. **`rmdir`:**
   ```bash
   rmdir nome_della_directory
   ```
   Il comando `rmdir` viene utilizzato per rimuovere una directory vuota. Se la directory contiene file o subdirectory, `rmdir` restituirà un errore.

   Ad esempio:
   ```bash
   rmdir directory_vuota
   ```

2. **`rm`:**
   ```bash
   rm -r nome_della_directory
   ```
   Il comando `rm` con l'opzione `-r` (ricorsivo) può essere utilizzato per rimuovere una directory e tutti i suoi contenuti (file e subdirectory). È molto potente, quindi è consigliabile usarlo con attenzione per evitare la rimozione accidentale di dati importanti.

   Ad esempio:
   ```bash
   rm -r directory_con_contenuto
   ```

Ricorda di prestare molta attenzione quando utilizzi `rm -r`, in quanto non c'è un passaggio indietro e la rimozione è irreversibile. Può essere utile aggiungere l'opzione `-i` per richiedere una conferma prima di eliminare ciascun file o directory:

```bash
rm -ri nome_della_directory
```

__________________________________



# CAP 2 TEXT MANIPULATION


PRINCIPIO GENERALE : IN LINUX TUTTO E' UN FILE!



Il comando `head` in Linux è utilizzato per visualizzare le prime righe di un file di testo. 


 `man head` per ulteriori dettagli sulle opzioni e il loro utilizzo.

1. **Visualizzare le prime 10 righe di un file (valore predefinito):**
   ```bash
   head nome_del_file
   ```
   Questo comando mostra le prime 10 righe del file specificato.

2. **Visualizzare un numero specifico di righe:**
   ```bash
   head -n numero_righe nome_del_file
   ```
   Questo comando mostra il numero specificato di righe del file. Ad esempio, `head -n 20 nome_del_file` mostrerà le prime 20 righe.

3. **Visualizzare le prime righe da più file:**
   ```bash
   head nome_file1 nome_file2
   ```
   Questo comando mostra le prime 10 righe di ciascun file.

4. **Visualizzare le prime righe di un output di un comando:**
   ```bash
   comando | head
   ```
   Puoi utilizzare `head` per visualizzare solo una parte dell'output di un comando. Ad esempio, `ls -l | head` mostrerà le prime 10 righe dell'output del comando `ls -l`.

5. **Visualizzare le prime righe di tutti i file nella directory corrente:**
   ```bash
   head *
   ```
   Questo comando mostra le prime 10 righe di ogni file nella directory corrente.

6. **Visualizzare le prime righe di un file con numeri di riga:**
   ```bash
   head -n 20 -v nome_del_file
   ```
   Questo comando mostra le prime 20 righe del file, indicando i numeri di riga.



**COMANDO TAIL**



Il comando `tail` in Linux è utilizzato per visualizzare le ultime righe di un file di testo. Ecco come puoi utilizzare il comando `tail`:

1. **Visualizzare le ultime 10 righe di un file (valore predefinito):**
   ```bash
   tail nome_del_file
   ```
   Questo comando mostra le ultime 10 righe del file specificato.

2. **Visualizzare un numero specifico di righe dalla fine del file:**
   ```bash
   tail -n numero_righe nome_del_file
   ```
   Questo comando mostra il numero specificato di righe dalla fine del file. Ad esempio, `tail -n 20 nome_del_file` mostrerà le ultime 20 righe.

3. **Visualizzare le ultime righe di più file:**
   ```bash
   tail nome_file1 nome_file2
   ```
   Questo comando mostra le ultime 10 righe di ciascun file.

4. **Visualizzare le ultime righe di un output di un comando:**
   ```bash
   comando | tail
   ```
   Puoi utilizzare `tail` per visualizzare solo una parte dell'output di un comando. Ad esempio, `ls -l | tail` mostrerà le ultime 10 righe dell'output del comando `ls -l`.

5. **Visualizzare le ultime righe di tutti i file nella directory corrente:**
   ```bash
   tail *
   ```
   Questo comando mostra le ultime 10 righe di ogni file nella directory corrente.

6. **Visualizzare le ultime righe di un file in tempo reale (log live):**
   ```bash
   tail -f nome_del_file
   ```
   Questo comando segue le modifiche apportate al file in tempo reale, mostrando continuamente le nuove righe aggiunte al file.



**NUMBERING THE LINES**


Sometimes—especially with very long files—we may want the file to display line numbers. Since snort.conf has more than 600 lines, line numbers would be useful here. This makes it easier to reference changes and come back to the same place within the file.
To display a file with line numbers, we use the nl (number lines) command.

<img width="639" alt="Screenshot 2024-02-16 alle 12 56 43" src="https://github.com/MrMagicalSoftware/linux-for-hacker-and-pentester/assets/98833112/9545585b-b572-4fbf-a8df-3634e1177533">


**FILTERING TEXT WITH GREP**


The command grep is probably the most widely used text manipulation command. 
It lets you filter the content of a file for display. 
If, for instance, you want to see all lines that include the word output in your snort.conf file, you could use cat and ask it to display only those lines


<img width="633" alt="Screenshot 2024-02-16 alle 12 58 42" src="https://github.com/MrMagicalSoftware/linux-for-hacker-and-pentester/assets/98833112/2da575c3-e933-4f40-8c99-3cd23eabb09c">


This command will first view snort.conf and then use a pipe (|) to send it to grep, which will take the file as input, look for lines with occurrences of the word output, and display only those lines.
The grep command is a very powerful and essential command for working in Linux, because it can save you hours of searching for every occurrence of a word or command in a file.


**Using sed to Find and Replace**


Il comando `sed` in Linux è un potente strumento di elaborazione del flusso di testo utilizzato per eseguire operazioni di ricerca, sostituzione e trasformazione su file di testo. 
Il nome "sed" deriva da "stream editor", che riflette il suo scopo principale di modificare e filtrare flussi di testo.


1. **Sostituire una stringa in un file:**
   ```bash
   sed 's/vecchia_stringa/nuova_stringa/' nome_del_file
   ```
   Questo comando sostituirà la prima occorrenza della `vecchia_stringa` con la `nuova_stringa` nel file specificato.

2. **Sostituire tutte le occorrenze di una stringa in un file:**
   ```bash
   sed 's/vecchia_stringa/nuova_stringa/g' nome_del_file
   ```
   Aggiungendo il flag `g`, il comando sostituirà tutte le occorrenze della `vecchia_stringa` con la `nuova_stringa` nel file.

3. **Sostituire in modo case-insensitive:**
   ```bash
   sed 's/vecchia_stringa/nuova_stringa/gI' nome_del_file
   ```
   L'opzione `I` rende la sostituzione case-insensitive.

4. **Eliminare righe che corrispondono a un modello:**
   ```bash
   sed '/modello_da_eliminare/d' nome_del_file
   ```
   Questo elimina tutte le righe che contengono il `modello_da_eliminare` nel file.

5. **Stampare solo le righe che corrispondono a un modello:**
   ```bash
   sed -n '/modello_da_stampare/p' nome_del_file
   ```
   L'opzione `-n` impedisce la stampa automatica delle linee, e il comando stampa solo le linee che corrispondono al `modello_da_stampare`.

6. **Sostituire la prima occorrenza su ogni riga:**
   ```bash
   sed 's/vecchia_stringa/nuova_stringa/'g nome_del_file
   ```
   Questo comando sostituirà la prima occorrenza della `vecchia_stringa` con la `nuova_stringa` su ogni riga del file.

7. **Sostituire solo sulla N-esima occorrenza su ogni riga:**
   ```bash
   sed 's/vecchia_stringa/nuova_stringa/N' nome_del_file
   ```
   Questo comando sostituirà solo la N-esima occorrenza della `vecchia_stringa` con la `nuova_stringa` su ogni riga.

8. **Eseguire più operazioni con sed:**
   ```bash
   sed -e 's/vecchia_stringa/nuova_stringa/' -e 's/altro_modello/altro_testo/' nome_del_file
   ```
   Puoi concatenare più espressioni `sed` utilizzando l'opzione `-e`.



__________________________________________________________________________



# Lavorare con grandi file 

For working with larger files, we have two other viewing utilities: more and less.


PRINCIPIO : "LESS IS BETTER THAN MORE"

I comandi `less` e `more` sono entrambi utilizzati per visualizzare il contenuto di file di testo su un terminale in modo paginato, il che significa che il testo viene visualizzato a schermo per pagine e puoi scorrere avanti o indietro attraverso di esse. Tuttavia, ci sono alcune differenze tra i due comandi.

### Comando `less`:

1. **Visualizzare un file:**
   ```bash
   less nome_del_file
   ```
   Il comando `less` visualizza il contenuto del file `nome_del_file` a schermo. Puoi scorrere avanti e indietro utilizzando i tasti direzionali.

2. **Ricerca all'interno del file:**
   - Puoi cercare all'interno del file premendo `/` e inserendo il testo da cercare. Premi `n` per andare alla successiva occorrenza, e `N` per tornare a quella precedente.

3. **Avanzamento e regressione per pagine:**
   - Puoi avanzare di una pagina premendo la barra spaziatrice e tornare indietro di una pagina premendo `b`.

4. **Uscire da `less`:**
   - Per uscire da `less`, premi la lettera `q`.

### Comando `more`:

1. **Visualizzare un file:**
   ```bash
   more nome_del_file
   ```
   Il comando `more` visualizza il contenuto del file `nome_del_file` a schermo. Puoi scorrere avanti premendo `Spacebar` e tornare indietro premendo `b`.

2. **Ricerca all'interno del file:**
   - La funzione di ricerca è limitata rispetto a `less`. Puoi cercare all'interno del file premendo `/` e inserendo il testo da cercare.

3. **Avanzamento e regressione per pagine:**
   - Puoi avanzare di una pagina premendo la barra spaziatrice e tornare indietro di una pagina premendo `b`.

4. **Uscire da `more`:**
   - Per uscire da `more`, premi `q`.




_______________________


# FONDAMENTI DI RETI 


<img width="648" alt="Screenshot 2024-02-16 alle 13 10 28" src="https://github.com/MrMagicalSoftware/linux-for-hacker-and-pentester/assets/98833112/f12cb616-6759-474b-a894-716a52128f9a">


Come si può vedere, il comando ifconfig mostra alcune informazioni utili sulle interfacce di rete attive sul sistema. In cima all'output c'è il nome della prima interfaccia rilevata, eth0 ➊, abbreviazione di Ethernet0 (Linux inizia a contare da 0 anziché da 1). Questa è la prima connessione di rete cablata. Se ci fossero altre interfacce Ethernet cablate, verrebbero visualizzate nell'output con lo stesso formato (eth1, eth2 e così via).
Il tipo di rete utilizzata (Ethernet) viene elencato successivamente, seguito da HWaddr e da un indirizzo; si tratta dell'indirizzo univoco globale impresso su ogni pezzo di hardware di rete, in questo caso la scheda di interfaccia di rete (NIC), solitamente indicato come indirizzo MAC (Media Access Control).
La seconda riga contiene informazioni sull'indirizzo IP attualmente assegnato a quell'interfaccia di rete (in questo caso, 192.168.181.131 ➋); il Bcast ➌, o indirizzo di broadcast, che è l'indirizzo utilizzato per inviare informazioni a tutti gli IP della sottorete; e infine la maschera di rete (Mask ➍), utilizzata per determinare quale parte dell'indirizzo IP è collegata alla rete locale.



La sezione successiva dell'output mostra un'altra connessione di rete chiamata lo ➎, abbreviazione di loopback address e talvolta chiamata localhost. 
Si tratta di un indirizzo software speciale che collega l'utente al proprio sistema. 
I software e i servizi non in esecuzione sul vostro sistema non possono utilizzarlo. 
Lo si potrebbe utilizzare per testare qualcosa sul proprio sistema, ad esempio il proprio server web. 

Localhost è generalmente rappresentato dall'indirizzo IP 127.0.0.1.

La terza connessione è l'interfaccia wlan0 ➏. Questa appare solo se si dispone di un'interfaccia o di un adattatore wireless, come nel mio caso.
Si noti che viene visualizzato anche l'indirizzo MAC del dispositivo (HWaddr).
Queste informazioni di ifconfig consentono di connettersi e manipolare le impostazioni della rete locale (LAN), un'abilità essenziale per l'hacking".



**iwconfig**

<img width="670" alt="Screenshot 2024-02-16 alle 13 16 32" src="https://github.com/MrMagicalSoftware/linux-for-hacker-and-pentester/assets/98833112/c2d9d1bb-8180-4b38-b109-9a9fb583a086">


We also learn from iwconfig the mode of the wireless extension (in this case, Mode:Managed, in contrast to monitor or promiscuous mode). 
We’ll need promiscuous mode for cracking wireless passwords.


**come cambiare il proprio ip**

Mi server per fare spoofing!
 ```bash
ifconfig eth0 192.168.181.115
 ```

cambiare la maschera di rete e il broadcast address

 ```bash
   ifconfig eth0 192.168.181.115 netmask 255.255.0.0 broadcast 192.168.1.255
 ```

**SPOOFING MAC ADDRESS**

 ```bash
ifconfig eth0 down
ifconfig eth0 hw ether 00:11:22:33:44:55kali 
ifconfig eth0 up
 ```


**DHCP SERVER**


Il comando `dhclient` in Linux è utilizzato per richiedere un indirizzo IP da un server DHCP (Dynamic Host Configuration Protocol) per una specifica interfaccia di rete. 

```bash
sudo dhclient eth0
```

Spiegazione delle parti del comando:

- `sudo`: Utilizzato per eseguire il comando con privilegi di amministratore, poiché la richiesta di un indirizzo IP può richiedere privilegi di root.
- `dhclient`: Il comando stesso per richiedere un indirizzo IP da un server DHCP.
- `eth0`: Specifica l'interfaccia di rete per cui si vuole richiedere un indirizzo IP. Può variare a seconda della configurazione del tuo sistema.

Quando esegui questo comando, `dhclient` invierà una richiesta DHCP alla tua rete, cercando un server DHCP disponibile. Se un server DHCP risponde con un indirizzo IP disponibile, il tuo sistema acquisirà quell'indirizzo e le informazioni di configurazione associati. Questo è particolarmente utile per ottenere un indirizzo IP dinamico in reti in cui il protocollo DHCP è in uso, come molte reti domestiche e aziendali.

“The dhclient command sends a DHCPDISCOVER request from the network interface specified (here, eth0). It then receives an offer (DHCPOFFER) from the DHCP server (192.168.181.131 in this case) and confirms the IP assignment to the DHCP server with a dhcp request.”


**DNS**



Il comando `dig` in Linux è utilizzato per eseguire query DNS (Domain Name System) per ottenere informazioni sui nomi di dominio.


```bash
dig hackers-arise.com ns
```

Spiegazione delle parti del comando:

- `dig`: Il comando stesso per eseguire query DNS.
- `hackers-arise.com`: Il nome di dominio per il quale si desidera ottenere informazioni.
- `ns`: Specifica il tipo di query DNS, in questo caso, stiamo cercando i record dei server dei nomi (NS).

L'output restituirà i record dei server dei nomi associati al dominio "hackers-arise.com".


You can also use the dig command to get information on email servers connected to a domain by adding the mx option (mx is short for mail exchange server)


```bash
dig hackers-arise.com mx
```

**cambiare il dns server**


```
leafpad /etc/resolv.conf
```
cambiare il nameserver con un nuovo DNS SERVER



**file etc/hosts**


Il file "/etc/hosts" è un file di configurazione presente nei sistemi operativi basati su Unix, inclusi Linux. Questo file viene utilizzato per associare indirizzi IP a nomi di host e viceversa, bypassando la necessità di una richiesta al server DNS (Domain Name System). In altre parole, è un meccanismo di risoluzione locale dei nomi.

Ecco come è strutturato un tipico file "/etc/hosts":

```plaintext
127.0.0.1   localhost
::1         localhost ip6-localhost ip6-loopback
fe00::0     ip6-localnet
ff00::0     ip6-mcastprefix
ff02::1     ip6-allnodes
ff02::2     ip6-allrouters

192.168.1.1  example.com
```

Spiegazione delle parti principali del file:

1. **Indirizzo IP loopback:**
   - Le linee che iniziano con "127.0.0.1" rappresentano l'indirizzo IP di loopback, che è solitamente associato al nome "localhost". Questo indirizzo è utilizzato per fare riferimento al proprio computer.

2. **Indirizzo IPv6 loopback:**
   - Le linee che iniziano con "::1" rappresentano l'indirizzo IPv6 di loopback e sono simili al caso IPv4.

3. **Altre definizioni di rete:**
   - Le linee successive forniscono definizioni aggiuntive, come la riservata rete IPv6 `fe00::0` e i prefissi multicast IPv6 `ff00::0`, `ff02::1`, `ff02::2`.

4. **Associazioni IP-Host:**
   - Le linee che seguono contengono associazioni IP-Host, dove un indirizzo IP è associato a un nome di host. Nell'esempio, "192.168.1.1" è associato al nome di dominio "example.com".

Questo file è utile per risolvere i nomi di dominio in indirizzi IP localmente, senza dover fare richieste al server DNS. Questo è particolarmente utile in situazioni in cui non si desidera o non si può utilizzare il DNS ufficiale, o quando si desidera sovrascrivere le risoluzioni DNS con configurazioni personalizzate.

USARE TAB E NON GLI SPAZI!!

Posso aggiungere www.bank.it 192.168.1.19 



___________________________________________



#  CAP 4 USO DI APT PER AGGIUNGRE E RIMUOVERE SOFTWARE 


COMANDI UTILI 

https://www.snort.org/


```bash

apt-cache search keyword
apt-cache search snort
apt-get install snort
apt-get remove snort
apt-get purge snort
apt-get update
apt-get upgrade

```

Aggiungrere repository


```bash

leafpad /etc/apt/sources.list

```

<img width="1434" alt="Screenshot 2024-02-16 alle 13 52 40" src="https://github.com/MrMagicalSoftware/linux-for-hacker-and-pentester/assets/98833112/068de9c5-ebd3-4278-bbfe-d484d728ef85">




Many Linux distributions divide repositories into separate categories. For instance, Ubuntu breaks out its repository categories as follows:

main Contains supported open source software

universe Contains community-maintained open source software

multiverse Contains software restricted by copyright or other legal issues

restricted Contains proprietary device drivers

backports Contains packages from later releases








